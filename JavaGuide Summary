JavaGuide Summary

Java
	基础
		概念
			JDK/JRE
			编译/解释
			字节码
			AOT
		基本数据类型
			包装类型缓存机制
			自动装箱拆箱
			精度丢失
			bigdecimal

		面向对象
			浅拷贝/深拷贝
			==/equals()
			hashcode()
			String/StringBffer/StringBuilder
			String不可变
			String +/常量折叠
		异常
			Throwable常用方法
			try with resources

		泛型
			泛型应用 
				自定义接口/集合类
		注解
			注解解析方式
				编译期直接扫描
				运行时通过反射处理
		SPI
			SPI/API
				
		序列化
			定义
			序列化协议
		IO
			BIO/AIO/NIO
		*汇总*
			值传递 
				java中基本类型是值的复制，引用类型是地址的复制（复制不是同一份）
				https://www.zhihu.com/question/31203609/answer/576030121

			序列化协议
				主要作用就是将结构和对象转换为便于传输体积更小的二进制流
				序列化存在于表示层
				java自带序列化效率低、安全性差、不支持跨语言
				kryo、protobuf
			代理模式
				静态代理
				动态代理
					cglib
						AMS运行时动态生成字节码
						不需要实现接口
					JDK
						必须要接口
						效率较高
			BigDecimal原理
				按十进制还原为整数，并记录精度（* 10 或者 * 1000）
			Unsafe类
				作用
					内存屏障
					CAS
					...
			SPI
				由服务调用者给服务提供者定义的接口
				java中的SPI是通过反射的方式判断实现类是否实现了规定接口
			语法糖的坑
				编译时泛型擦除
				运行时无法判断泛型类型
				类泛型擦除后静态变量会关联到同一个地方 Fan<T>不同类的静态变量是一样的
				增强for的concurrentModificationException

	集合
		list
			ArrayList/Vector
				初始化 默认空数组 +1 = 10
				扩容
					1.5倍
					Integer.MAX_VALUE限制
					ensureCapicity
			LinkedList
				remove效率不如ArrayList https://www.cnblogs.com/NickyYe/p/4461454.html
			randomAccess
		Set
			HashSet/LinkedHashSet/TreeSet
		Queue
			Queue/Deque
			ArrayDeque/LinkedList
				垃圾LinkedList
			PriorityQueue
				二叉堆
		Map
			HashMap/HashTable
				长度/线程安全/底层实现/效率/null
			HashMap/TreeMap
			HashSet
			HashMap底层实现/长度2^n/遍历方式/死锁/线程安全
				hash扰动
				长度2^n 与运算等效于取余
				多线程问题
				遍历方式 https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw 尽量用entrySet迭代
				负载因子
				put流程
				get流程
				resize *2 element重新分配
			HashTable/ConcrruentHashMap
				1.7/1.8
					结构
						segment
						数组+链表/红黑树
					并发数量
						默认16segment
						node节点数量
					并发实现
						cas + 自旋 + synchronized
				结构
				锁粒度
		注意事项
			判空
			转map
				value不为null
			遍历
				iterator删除
			fail fast
			集合转数组
				toArray(new T[0])
			数组转集合
				Arrays.asList()返回的是Arrays里的一个内部类
				必须是对象数组
				不能修改转化后的集合
				用new ArrayList<>(Arrays.asList(Object[] {}))
	源码
		IO
			IO分类
				字节/字符流
				缓冲字节/字符流
				RandomAccessFile
			设计模式
				装饰器
				适配器
				工厂
				观察者
			IO模型
				BIO
					read之后阻塞
				NIO
					read之后不断轮询
					多路复用为epoll之后等待回调通知
				AIO
					第二阶段数据拷贝由内核操作，并不影响进程，通过回调通知进程
		并发
			进程/线程/协程
				cpu执行时间
				上下文切换成本粒度
				共享的资源
					本地方法栈
					虚拟机栈
					程序计数器
			多线程
			线程生命周期
				就绪 start
				阻塞 synchronized
				有限等待 sleep
				无限等待 wait
				死亡 system.exit()
			死锁
				互斥
				请求和保持
				不可剥夺
				循环
			sleep/wait/join/yield
				sleep用于thread，当前线程不让出其占用的所有锁
				wait用户对象，当前线程让出改对象锁
				被调用的join线程优先执行，之后调用线程再执行
				yield暂停当前线程
			锁
				乐观锁/悲观锁
				CAS
			JMM
				CPU高速缓存
				多核CPU中内存不一致
				MESI协议
				指令重排序
				内存屏障
				JMM定义
					Java为跨平台中解决多线程指令重排问题定制的一组规范
					本地内存/主内存
						为了提高效率？
				happens-before
					JMM根据happens-before原则去禁止某种类型的指令重排序
			volatile
				可见性
					从主存中读取
				禁止指令重排
					内存屏障
				无原子性
					不能保证多线程读取的先后顺序
			synchronized
				原理
					修饰方法 方法前ACC标识
						修饰静态方法 给class对象上锁
						修饰实例方法 给实例对象上锁
					修饰代码块 对象头的monitor_enter monitor_exit
				优化
					偏向锁
					轻量级锁
					重量级锁
				synchronized/volatile
					都是线程同步的方式
					一个能保证线程安全一个不能
				synchronized/reentrantLock
					都是可重入
					公平/非公平
					可中断/可通知
				ReentrantReadWriteLock
					一把读锁一把写锁
					共享锁/独占锁
				StampedLock
					不可重入
					不支持condition通知
			ThreadLocal
				原理
					ThreadLocalMap
						存在Thread中 key为ThreadLocal引用 value为ThreadLocal存放的值
				风险
					内存泄漏 Thread->ThreaLocalMap->Entry->Value的强引用链不会被回收
						手动调用remove才会清理key为null的entry
				set
				扩容
				清理
					探测式清理
					启发式清理
			Atomic
				CAS + volatile支持并发度较小的情况
			线程池
				参数
					重要
						corePoolSize
						maxPoolSize
						阻塞队列
							ArrayBlockingQueue
							LinkedBlockingQueue
							SynchronousQueue
					不重要
						饱和策略
						时间单位
						keepAliveTime
						线程工厂
				Executors
					不建议使用因为各种OOM
				饱和策略
					丢弃
					新开线程处理
					异常
				原理
					先满足核心线程数
					再放入阻塞队列
					再填充最大线程数
					再执行拒绝策略
				大小设置
					CPU密集型 排序计算 n + 1
					IO密集型 文件数据读写 2n
				注意事项
					命名
					加监控
			AQS
				原理
					CLH队列+state计数器
				Semaphore
					线程共享信号量，限定一次n个线程同时执行
				CountDownLatch
					单次计数器，当n个线程执行完后执行await线程
				CyclicBarrier
					可重复计数器，当n个线程执行完调用await之后执行action动作
		*重要*
			乐观锁/悲观锁
				实现/版本号/CAS
				存在问题/ABA
					ABA危害 https://www.cnblogs.com/yingying7/p/12573240.html
			Atomic
				原理
				应用场景？
			ThreadLocal
				数据结构
				内存泄漏
				hash
				set/get
				过期key
				扩容
				InheritableThreadLocal
				实践
			CompletableFuture
	JVM
		内存区域
			运行时数据区
				程序计数器
				Java虚拟机栈
					存放方法调用的局部变量、动态链接、方法返回地址
				本地方法栈
					nvtive方法调用的栈
				堆
					新生代
					老年代
					方法区/永久代/元空间
				方法区
					1.8之后合并到元空间，减少OOM
				运行时常量池
					存一些整数、浮点数和符号引用，1.8之后跟着方法区合到元空间了
				字符串常量池
					专门存字符串，1.7之后位于堆中
				直接内存
			HotSpot对象
				创建
					类型检查
					分配内存
						TLAB + CAS
					初始化零值
					设置对象头
					init

				内存布局
					对象头
					数据
					对齐填充
				访问定位
		垃圾回收
			堆空间
				新生代
					Eden S0 S1
					比例 8:1:1
					存活时间 1 << 4 - 1 = 15 也可能不是15

				老年代
					新生代对象超过生命周期之后放入老年代
				永久代
					大对象大数组之类直接扔永久代
			内存分配回收

			死亡对象判断
				可达性分析
				引用计数法
				引用
					强引用
					软引用 用作内存敏感的缓存
					弱引用
					虚引用
			垃圾收集算法
				标记清除
				复制
				标记整理
				分代
			垃圾收集器
				serial
				parNew
				CMS
					流程
						初始标记
						并发标记
						最终标记
						标记清楚
					问题
						无法处理浮动垃圾
						内存碎片多
					三色标记法
						过程
							gcroot标黑
							相关标灰
							不相关标白
							清除白色
						错误
							漏标
							错标
						解决
							类似AOP写屏障
				G1
					特点
						暂停时间短
						时间可预测
						并发GC
						筛选回收
						适合内存较大、浮动垃圾多情况
					结构
						S E O H
						记忆集
						卡表
					设置
						预期暂停时间
						避免手动设置比例

				ZGC
		类文件结构
			class结构
		类加载过程
			类生命周期
				
			加载流程
				加载 获取二进制流在内存中生成对象
				验证 文件格式元数据字节码验证
				准备 分配内存设置初始值
				解析 符号引用替换为直接引用
				初始化 执行初始化方法
			卸载
				没有引用的自定义类加载器加载的类
		类加载器
			双亲委派
				自底向上检查类加载器，自顶向下尝试加载
				作用
					保护原生类，避免重复加载
				打破
					重写loadClass方法
					场景
						tomcat不同版本应用
			自定义类加载器
				场景
					加载加密后的java class
			自定义object类
		JVM参数
			堆内存相关
				最大最小堆 xms xmx
			垃圾收集相关
				-XX: +UseG1GC
			OOM
				-XX:+HeapDumpOnOutOfMemoryError 将OOM错误转储到物理文件中
		JVM调优
			Xmx Xms设置为相同避免扩容
			xmn设置为堆大小的3/8

		JDK工具
			命令行工具
				jps 查看jvm相关进程
				jstat -gc 查看gc信息
				jmap 查看jvm中class和对象内存使用情况
				jstack 查看虚拟机快照
	Java新特性
		8
			匿名函数
			stream
			optional
			date time		

计算机基础
	网络
		常见面试题
			TCP/UDP
				区别
					可靠性
					建立连接
					面向流和报文
					一对一和n对n
				适用场景
					tcp 请求
					udp 视频 会话 聊天
			HTTP
				一次请求过程
					dns解析ip
					tcp建立连接
					http请求逐层包装
					arp解析局域网寻址
					ip解析路由转发
					逐次拆包获得响应报文
					解析后页面加载渲染
				HTTP保存用户状态
					无状态协议
					cookie
						客户端保存的信息
					session
						服务端保存的数据
					token
						认证令牌用于核对请求是否合法
				URI/URL
					URI > URL

			ARP
				MAC
				工作原理
					解析MAC，转发之后替换成自己的MAC
		重要
			OSI
				7层协议
			TCP/IP
				4层
			应用层协议
				HTTP 
				Telnet 不安全会话
				POP3 邮件 
				SMTP 邮件
				FTP 传文件
				SSH 会话
			HTTP
			HTTPS
				加密流程
					对称加密内容
					非对称加密对称加密秘钥
					浏览器内置公钥对证书解密获得非对称加密公钥
				TLS
				SSL
			HTTP版本
				1.0
				1.1
					缓存
					keep-alive tcp链接不断开
					加了错误码
				2.0
					多路复用tcp连接
					二进制解析
					header压缩
				3.0
					QUIC
						没有握手
						0RTT能建立连接
			HTTP状态码
				2xx
					200 成功
					201 成功修改
				3xx
					301 永久转移
					302 临时转移
				4xx
					401 没权限
					403 forbidden
					404 not found
					405 方法不对
					409 版本不对
				5xx
					500 服务器错误
					502 服务没起来
					503 服务器过载维护
					504 请求超时 nginx配错了
			TCP建立连接
				三次握手
					A请求B ACK
					B同意A+请求A SYN + ACK
						半连接 没有完成三次握手也可发数据
						sync攻击 大量sync使得服务端重复发送syn + ack
							ip限制
							频率限制
							减少重试
							减少释放连接时间
					A同意B SYN
				四次挥手
					A请求B断开 FIN A fin_wait_1
					B同意A断开 ACK B close_wait A fin_wait_2
					B请求A断开 FIN B last_ack 
					A同意B断开 ACk A time_wait
						2MSL
							保证收到ACk，收不到key重发ACK请求
							让该链接所有报文消失，防止下次出现
						大量time_wait
							短效连接
								解决：减少等待时间、允许time_wait建立新链接
				粘包
					设计划分tcp报文的方法
						chunked
						content-length
				tfo
					首次建立连接时服务端回传了syn cookie
					第二次客户端直接发送syn + cookie + http请求后，客户端就能返回http response
			TCP可靠性
				连接管理
				流控：针对端到端
					滑动窗口
						ARQ协议
							停等
							连续ARQ
				拥塞控制：针对网络
					慢开始 1 -> 每次翻倍
					拥塞控制 n +1 +1
					快重传 3次收到报文1的ack，重传报文2
					快恢复 慢开始门限减半，窗口==慢开始门限
			ARP协议
				地址解析
			同源策略
				浏览器跨域名资源不能访问
				解决跨域
					iframe
					cookie在二三级域名之间能访问
	操作系统
		常见面试题
			基础
				操作系统定义
				系统调用
					用户态/内核态
						低权限，普通用户进程所处的状态
						高权限，可以访问几乎所有资源
					设备管理
					文件管理
					进程控制
					进程通信
						管道 父进程fork出子进程，在内核区开辟内存，父进程留写端，子进程留读端，实现数据流写入
							命名管道
							匿名管道 |
						共享内存 多个进程将虚拟内存映射到同一块物理内存
						socket
						消息队列
						信号 kill -9
						信号量 类似java的semaphore，允许多线程/进程同时访问临界资源



					内存管理
						分类
							同等块式
							同等页式 < 块式
							代码分段式
							段页式
						虚拟内存
							每个进程有自己独立的逻辑内存空间，防止对内核以及相互之间发生干扰
			进程/线程/协程
				都是CPU执行一段时间的描述，区别在于时间的长短、占用的资源开销
				多线程 线程之间会相互影响，但是上下文切换成本小，适用于CPU频繁切换计算密集场景
				多进程 进程之间影响小，适用于分布式主机之间通信
				协程 用户态的微线程，有自己的寄存器和栈

		Linux
			文件系统
				inode：记录文件元信息
			基本命令
				find 查找文件内容
				lsof 查看打开文件
				ps 查找进程
				top 查看当前所有进程
				netstat 查看网络端口
			环境变量
				用户环境变量 ~/.*
				系统环境变量 /etc/*
	数据结构
		数组/链表/栈/队列
			应用场景
		堆
			定义
			存储
			操作
			排序
		树
			分类
			存储
		红黑树
		布隆过滤器
			redis中布隆过滤器

数据库
	基础知识
		drop/delete/truncate
		数据库结构设计流程
	NoSQL
		SQL/noSQL
		优势
		类型
	字符集
		常见字符集
			ASCII
			unicode/UTF-8
			GB2312
		MySQL字符集
	MySQL常见面试题
		基础架构
			连接器：建立连接，用户登录
			检查器：语法检查
			优化器：执行索引优化
			执行器：实际执行
			插件式存储引擎：存储数据、提供api
		存储引擎
			InnoDB对比MyISAM
				外键支持
				支持事务
				锁级别细化
				资源消耗大
				索引主键为聚簇索引，非主键为辅助索引
		索引
			功能分类
				index
				unique
				primary
				fulltext：原理为倒排
			结构
				B+树
					聚集索引：叶子存数据
					非聚集索引：叶子存主键id
				hash：memoery引擎使用
			索引优化
				最左前缀匹配
					最左侧索引应当业务使用率高、区分度高、分布稀疏
					左侧索引范围查询会导致后续索引失效

			优化

		查询缓存
			条件
				SQL一致、表结构一致、字符集一致、大小写不敏感
			提高命中率
				固化SQL
				加内存
				表加分区，让数据固化

		日志
			bin log：用于主从同步
				statement：记录单次修改的DML
				row：详细行记录，可以反应函数和存储过程，采用了gtid之后，一般用row模式
				gtid：全局事务唯一id，在主从切换时可以通过自动匹配gtid而省去binlog中断点
			redo log：用顺序写代替随机写作为缓存，写满之后批量写磁盘，用于宕机恢复
				两阶段提交：为保证数据正确性，需要redo log和bin log中数据一致
					事务记录到redo log，状态为prepare
					事务记录到binlog
					redo log中数据修改为commit
			undo log：MVVC中记录版本，用于回滚
			retry log：从库同步bin log产生的log
			slow log：慢查询日志
		事务
			事务隔离级别
				未提交读：无事务
				提交读：解决脏读
				可重复读：解决不可重复读
					next-key lock也可解决幻读
				串行化：解决幻读 读时共享 写时排他
			MVVC：在提交读和可重复读级别下的机制
				事务中的每个操作有一定的可见范围，标识其他事务的数据是否对当前事务可见
				可重复读的select不会产生新的readView
		锁
			机制划分
				乐观锁：MVVC
				悲观锁：一般都是悲观锁
			粒度划分
				行锁
				表锁
				页锁
				gap lock
				next key lock：加在索引上，锁定一行+一侧/两侧范围
			操作分类
				读锁：共享锁
				写锁：排他锁
			其他
				意向锁：在加行锁的时候会给整个表加表级意向锁防止其他加表锁操作
			操作加锁
				select MVVC 乐观锁
				select in share mode 共享锁
				delete/update/select for update 排他锁 innodb中update没有索引是表锁，有索引是行锁
		DML
			join
				left/right/outer/inner：左全/右全/并集/交集
			in/exist
				in：结果集放内存
				exist：不缓存结果，每条外部记录进行一次子查询，适用于子查询大的情况
			limit
				原理
					从头遍历
				深度分页
					禁止跳页，每次查询传主键id
					ES存id，用id避免回表

		性能优化
			问题排查
				explain显示查询路径
				show processlist查看当前mysql线程
				开启慢查询日志，查看慢查询sql
			慢查询优化
				no cache看运行效率
				explain查看执行计划，每张表的查询是否符合预期，联表查询顺序是否合理
				调整索引，避免回表，设置索引下推
					回表：查询的数据需要去主键索引上额外查询
					索引下推：5.6之后将server中的过滤条件下放到非主键索引中（如果筛选字段在非主键索引中的话）
			大表优化
				垂直拆分：按列拆
				水平拆分：按行拆
					方式
						取模
						哈希
						范围
						分布式id
							snowflake：规则
							uuid：不规则
			分布式方案
				读写分离
					主库宕机：半同步复制，从库ack完才算一次完整操作
					同步延时：并行复制
	MySQL性能优化
		命名规范
		基本设计规范
		字段设计规范
			字段尽可能保证not null https://opensource.actionsky.com/20190710-mysql/
			用timestamp和datetime存时间
		索引设计规范
			索引最好不超过5个
			禁用全文索引
		SQL规范
			in 的值不要超过 500 个
			WHERE 从句中禁止对列进行函数转换和计算
		操作行为规范
			超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作
	*重要*
		索引
			优缺点
			数据结构
			索引类型
			聚簇索引/非聚簇索引
			覆盖索引/联合索引
			索引下推
			相关建议
		日志
			redo log
			bin log
			两阶段提交
			undo log
		事务隔离级别
			脏读
			不可重复读
			幻读
		InnoDB/MVVC
			锁定读/非锁定读
			MVVC实现
			MVVC解决不可重复读
			Next-key-lock
		SQL执行流程
			基本架构
			语句执行分析
		MySQL执行计划
			如何分析explain结果

		MySQL自增组件连续性
		MySQL时间存储建议
		MySQL隐式转换造成索引失效
	Redis
		基础
		数据结构
		线程模型
		内存管理
		持久化机制
		事务
		性能优化
		生产问题
		集群
	*重要*
		缓存读写策略
		基本数据结构
			string
			list
			set
			zset
			hash
		特殊数据结构
			bitmap
		内存碎片
	ES
	MongoDB
		基础
		存储引擎
		聚合
		事务
		数据压缩
		索引
		高可用


开发工具
	maven
		核心概念
			作用
			坐标
			依赖
			仓库
			生命周期
			插件
			多模块管理
	git
		核心概念
			基本操作
	docker
		核心概念
			容器
			概念
			容器VS虚拟机
			基本概念
			常见命令
			底层原理

常用框架
	spring常见面试题
		spring基础
		spring IOC
		spring AOP
		spring MVC
		设计模式
		spring事务
	spring常用注解
	*重要*
		事务详解
		设计模式
		自动装配原理
	Mybatis常见面试题

系统设计
	restful api
		定义
		规范
	软件工程
		基本策略
	代码命名
		命名规则
		常见规范
	代码重构
		重构时机
		注意事项
	单测
		作用
		TDD
	认证
		RBAC
		cookie/session
		JWT
		SSO
		Oauth2.0
	JWT
		组成
		身份验证
		防止篡改
		安全性
		优势
		常见问题
	SSO
		作用
		设计实现
	权限系统
		设计方式
		设计思想
		核心模块
	系统设计面试题？
	敏感词过滤
		算法实现
	Java定时任务
		单机
		分布式
	web消息推送
		常见方案

分布式
	CAP&BASE
		CAP理论
		BASE理论
	Paxos
	Raft
		基础
		领导人选举
		日志复制
		安全性
	API网关
		常见网关
	分布式ID
		解决方案
	分布式锁
		方案
		基于redis的分布式锁
	分布式事务
	分布式配置中心
	RPC
		原理
		框架
		设计实现
	Dubbo
		分布式基础
		架构
		负载均衡
		序列化协议
	ZK
		基础
		概念
		集群
		ZAB协议&paxos算法
		一致性问题
		一致性协议算法
		ZAB
		ZK应用


高性能
	分库分表/读写分离
	负载均衡
	CDN
		原理
	SQL优化
	消息队列
		作用
		问题
		JMS/AMQP
		选型
	Kafka
		应用场景
		对比
		存在问题
	RabbitMQ
		队列模型/主题模型
		架构图
		问题
		分布式事务
		刷盘机制
		死信队列

高可用
	设计指南
		提高可用性的方法
	冗余设计
	服务限流
		限流算法
	降级&熔断
	超时&重试
	性能测试
		注意的点
		测试指标
		测试种类
		测试工具














