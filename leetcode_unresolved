{'id': '剑指 Offer 37', 'name': '序列化二叉树'} 广度遍历，java转成字符串直接用节点数组遍历拼接即可 TODO out of memory 难顶，放弃了 UNCHECKED
{'id': '337', 'name': '打家劫舍 III'} 原先思路：递归（超时）done 之后优化：递归+记忆化（通过） 更先进的思路：动态规划 难点在于：二叉树的dp状态如何构建 -> 用字典即可，一个字典保存包含自身的最大值，另一个字典保存不包含自身的最大值，通过dfs即可从下往上构建dp CHECKED
{'id': '剑指 Offer 26', 'name': '树的子结构'} 原思路：暴力针对每个节点进行比对 解法：其实差不多，先动手写一下吧。。。 TODO done UNCHECKED
{'id': '236', 'name': '二叉树的最近公共祖先'} 原思路：无 解法：从底向上寻找公共节点进行返回即可，后序遍历（注意把问题情况理清楚，1：在节点两侧；2：p为节点且q在子节点中；3：q为节点且p在子节点中） TODO done CHECKED
{'id': '124', 'name': '二叉树中的最大路径和'} 原思路：递归即可 解法：确实递归就行 TODO done CHECKED

{'id': '301', 'name': '删除无效的括号'} 解法：回溯 + 剪枝 为啥跟dfs和bfs有关？不懂 TODO done （不要想着remove，直接用逐个add的方法，以及利用左右括号的分数，回溯过程中让得分有效即可） UNCHECKED
 回溯算法相关：

什么括号啊，运算啊，统统都有着先进后出的特性，可以通过栈进行运算
{'id': '162', 'name': '寻找峰值'} TODO (二分的条件以及终止边界条件需要注意) CHECKED
{'id': '268', 'name': '丢失的数字'} done CHECKED
{'id': '48', 'name': '旋转图像'} done (注意通过标记防止重复旋转) CHECKED
{'id': '315', 'name': '计算右侧小于当前元素的个数'} 归并排序+索引数组 TODO UNCHECKED
{'id': '29', 'name': '两数相除'} 原思路：1+2+4+8 解法：直接1->2->4->8就能确定，没必要复杂化 UNCHECKED
除法、n次方、平方根之类的求值都可以先用变步长确定范围（1->2->4->8)然后再用二分法求精确值 done but TODO (注意边界移除问题，以及二分的方法)
{'id': '338', 'name': '比特位计数'} 原思路：遍历所有数字，对每个数字进行二进制转换，判断其中位数为1的数量 解法：奇偶位判断，伪动态规划 f(n) = f(n - 1) + 1 && f(n) = f(n / 2) done CHECKED
{'id': '371', 'name': '两整数之和'} 原思路：无 解法：主要是两个数同一位为1的情况需要进位，这种进位的情况需要不断循环相加处理，直到没有需要进位为止 TODO （补码的位运算，分为进位和无进位加法）UNCHECKED
{'id': '190', 'name': '颠倒二进制位'} 原思路：无 解法：将原数字不断左移，取最左边的数字作为结果，不断右移并和被移出的数字取与 TODO （翻转也可以用二进制的位下标，因为位数为固定32位）CHECKED
{'id': '8', 'name': '字符串转换整数 (atoi)'} 原思路：遍历字符，获取有效字符串后转化为数字 解法：自动机，根据状态转移map来进行识别并进行计算（这属于一边识别一边计算） TODO done (不用自动机，在循环中做状态转换即可) 臭狗屎题目，边界条件太难了 CHECKED
{'id': '127', 'name': '单词接龙'} done (单词领接表字典 + bfs简简单单) CHECKED
{'id': '剑指 Offer 49', 'name': '丑数'} 3指针，好好琢磨即可 done but TODO CHECKED
{'id': '149', 'name': '直线上最多的点数'} 暴力即可 done but TODO CHECKED
{'id': '347', 'name': '前 K 个高频元素'} 原思路：记录次数后排序 解法：记录次数后快排切分 done CHECKED


daily leetcode
2023年10月7日：
	88. 合并两个有序数组 逆向双指针 普通双指针 CHECKED
    80. 删除有序数组中的重复项 II 快慢指针+计数器 TODO CHECKED
    189. 轮转数组 翻转数组 TODO UNCHCKED
	380. O(1) 时间插入、删除和获取随机元素 哈希表+数组末尾删除交换 TODO CHECKED
    134. 加油站 TODO 贪心+过往路径开始的任一起点都是无效起点 CHECKED
    12. 整数转罗马数字 TODO 贪心hash表 CHECKED
    14. 最长公共前缀 TODO 链表找前缀 CHECKED
    289. 生命游戏 TODO 不用额外空间，用额外状态标识即可 CHECKED
    173.二叉搜索树迭代器 TODO 空间复杂度O(h) 不道啊 CHECKED ps：用栈就行
    222.完全二叉树的节点个数 TODO O(lgn)利用右子树最左侧节点和左子树最左侧节点进行对比，一致或不一致都可以递归 CHECKED
    210.课程表2， 拓扑排序需要组件=入度表+邻接表+已走过路径记录表+广度遍历 TODO CHECKED


2024年03月25日：
    518.零钱兑换2

2024年04月10日：
    [1702]修改后的最大二进制字符串 模拟 + 贪心 不断把0111110变成1011111，相当于1进行前移
    [1766]互质树 回溯 但是超时了

<<<<<<< HEAD
2024年5月28日：
	2903. 找出满足差值条件的下标 I 一次遍历即可
=======
2024年05月03日：
    2462. 雇佣 K 位工人的总代价 java自带的最小堆
>>>>>>> 4e8b1d7 (feat)
