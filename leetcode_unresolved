{'id': '剑指 Offer 37', 'name': '序列化二叉树'} 广度遍历，java转成字符串直接用节点数组遍历拼接即可 TODO
{'id': '337', 'name': '打家劫舍 III'} 原先思路：递归（超时）done 之后优化：递归+记忆化（通过） 更先进的思路：动态规划 难点在于：二叉树的dp状态如何构建 -> 用字典即可，一个字典保存包含自身的最大值，另一个字典保存不包含自身的最大值，通过dfs即可从下往上构建dp
{'id': '剑指 Offer 26', 'name': '树的子结构'} 原思路：暴力针对每个节点进行比对 解法：其实差不多，先动手写一下吧。。。 TODO done
{'id': '236', 'name': '二叉树的最近公共祖先'} 原思路：无 解法：从底向上寻找公共节点进行返回即可，后序遍历（注意把问题情况理清楚，1：在节点两侧；2：p为节点且q在子节点中；3：q为节点且p在子节点中） TODO done
{'id': '124', 'name': '二叉树中的最大路径和'} 原思路：递归即可 解法：确实递归就行 TODO done

{'id': '301', 'name': '删除无效的括号'} 解法：回溯 + 剪枝 为啥跟dfs和bfs有关？不懂 TODO done （不要想着remove，直接用逐个add的方法，以及利用左右括号的分数，回溯过程中让得分有效即可）
 回溯算法相关：

什么括号啊，运算啊，统统都有着先进后出的特性，可以通过栈进行运算
{'id': '162', 'name': '寻找峰值'}
{'id': '268', 'name': '丢失的数字'}
{'id': '48', 'name': '旋转图像'}
{'id': '315', 'name': '计算右侧小于当前元素的个数'} 归并排序+索引数组 TODO
{'id': '29', 'name': '两数相除'} 原思路：1+2+4+8 解法：直接1->2->4->8就能确定，没必要复杂化
除法、n次方、平方根之类的求值都可以先用变步长确定范围（1->2->4->8)然后再用二分法求精确值
{'id': '338', 'name': '比特位计数'} 原思路：遍历所有数字，对每个数字进行二进制转换，判断其中位数为1的数量 解法：奇偶位判断，伪动态规划 f(n) = f(n - 1) + 1 && f(n) = f(n / 2)
{'id': '371', 'name': '两整数之和'} 原思路：无 解法：主要是两个数同一位为1的情况需要进位，这种进位的情况需要不断循环相加处理，直到没有需要进位为止
{'id': '190', 'name': '颠倒二进制位'} 原思路：无 解法：将原数字不断左移，取最左边的数字作为结果，不断右移并和被移出的数字取与
{'id': '8', 'name': '字符串转换整数 (atoi)'} 原思路：遍历字符，获取有效字符串后转化为数字 解法：自动机，根据状态转移map来进行识别并进行计算（这属于一边识别一边计算） TODO
{'id': '127', 'name': '单词接龙'}
{'id': '剑指 Offer 49', 'name': '丑数'} 
{'id': '149', 'name': '直线上最多的点数'}
{'id': '13', 'name': '罗马数字转整数'}
{'id': '347', 'name': '前 K 个高频元素'} 原思路：记录次数后排序 解法：快排切分 TODO