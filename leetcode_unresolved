{'id': '剑指 Offer 37', 'name': '序列化二叉树'} 广度遍历，java转成字符串直接用节点数组遍历拼接即可 TODO
{'id': '337', 'name': '打家劫舍 III'} 原先思路：递归（超时） 之后优化：递归+记忆化（通过） 更先进的思路：动态规划 难点在于：二叉树的dp状态如何构建 -> 用字典即可，一个字典保存包含自身的最大值，另一个字典保存不包含自身的最大值，通过dfs即可从下往上构建dp
{'id': '剑指 Offer 26', 'name': '树的子结构'} 原思路：暴力针对每个节点进行比对 解法：其实差不多，先动手写一下吧。。。 TODO
{'id': '236', 'name': '二叉树的最近公共祖先'} 原思路：无 解法：从底向上寻找公共节点进行返回即可，后序遍历（注意把问题情况理清楚，1：在节点两侧；2：p为节点且q在子节点中；3：q为节点且p在子节点中） TODO
{'id': '124', 'name': '二叉树中的最大路径和'} 原思路：递归即可 解法：确实递归就行 TODO

{'id': '301', 'name': '删除无效的括号'} 解法：回溯 + 剪枝 为啥跟dfs和bfs有关？不懂 TODO
{ 'id': '980', 'name': '不同路径 III'} 原思路：深度搜索+回溯 思路对了，就是不知道为啥一直没通过 TODO
 {'id': '131', 'name': '分割回文串'} 解法：深度遍历+回溯（其实字符串分割也可以视作深度遍历的。。。每次切分都是二叉树中的一条决策路径） UNDO
 回溯算法相关：

什么括号啊，运算啊，统统都有着先进后出的特性，可以通过栈进行运算
{'id': '560', 'name': '和为K的子数组'}
{'id': '剑指 Offer 04', 'name': '二维数组中的查找'}
{'id': '162', 'name': '寻找峰值'}, {'id': '75', 'name': '颜色分类'}
{'id': '79', 'name': '单词搜索'}, {'id': '15', 'name': '三数之和'}, {'id': '53', 'name': '最大子序和'}
{'id': '121', 'name': '买卖股票的最佳时机'} 动态规划 
{'id': '268', 'name': '丢失的数字'}
{'id': '48', 'name': '旋转图像'}
[{'id': '剑指 Offer 11', 'name': '旋转数组的最小数字'}]
{'id': '454', 'name': '四数相加 II'} 哈希表，和两数相加类似
{'id': '315', 'name': '计算右侧小于当前元素的个数'} 归并排序+索引数组 TODO
{'id': '29', 'name': '两数相除'} 原思路：1+2+4+8 解法：直接1->2->4->8就能确定，没必要复杂化
除法、n次方、平方根之类的求值都可以先用变步长确定范围（1->2->4->8)然后再用二分法求精确值
{'id': '240', 'name': '搜索二维矩阵 II'} 原思路：暴力 解法：根据二维数组特性，类似于二叉树遍历，从左下或者右上开始遍历
{'id': '338', 'name': '比特位计数'} 原思路：遍历所有数字，对每个数字进行二进制转换，判断其中位数为1的数量 解法：奇偶位判断，伪动态规划 f(n) = f(n - 1) + 1 && f(n) = f(n / 2)
{'id': '279', 'name': '完全平方数'} 原思路：无 解法：动态规划，只是复杂度为 O(n * sqrt(n))而已
{'id': '416', 'name': '分割等和子集'} 原思路：暴力枚举 解法：动态规划，01背包问题，通过二维数组列出所有组合 的可能结果 dp[i][j] i为位数，j为总和
{'id': '剑指 Offer 39', 'name': '数组中出现次数超过一半的数字'} 原思路：哈希表 解法：摩尔投票法，因为数字出现次数超过半数，所以用+1-1取结果必定大于0
{'id': '371', 'name': '两整数之和'} 原思路：无 解法：主要是两个数同一位为1的情况需要进位，这种进位的情况需要不断循环相加处理，直到没有需要进位为止
{'id': '190', 'name': '颠倒二进制位'} 原思路：无 解法：将原数字不断左移，取最左边的数字作为结果，不断右移并和被移出的数字取与
{'id': '8', 'name': '字符串转换整数 (atoi)'} 原思路：遍历字符，获取有效字符串后转化为数字 解法：自动机，根据状态转移map来进行识别并进行计算（这属于一边识别一边计算） TODO
{'id': '127', 'name': '单词接龙'}
{'id': '剑指 Offer 49', 'name': '丑数'} 
{'id': '149', 'name': '直线上最多的点数'}
{'id': '202', 'name': '快乐数'}
{'id': '204', 'name': '计数质数'}
{'id': '13', 'name': '罗马数字转整数'}
{'id': '138', 'name': '复制带随机指针的链表'}
{'id': '3', 'name': '无重复字符的最长子串'} 原思路：动态规划O(n2) 解法：滑动窗口
{'id': '347', 'name': '前 K 个高频元素'} 原思路：记录次数后排序 解法：快排切分 TODO