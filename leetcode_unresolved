{'id': '剑指 Offer 37', 'name': '序列化二叉树'} 广度遍历，java转成字符串直接用节点数组遍历拼接即可 TODO
{'id': '337', 'name': '打家劫舍 III'} 原先思路：递归（超时）done 之后优化：递归+记忆化（通过） 更先进的思路：动态规划 难点在于：二叉树的dp状态如何构建 -> 用字典即可，一个字典保存包含自身的最大值，另一个字典保存不包含自身的最大值，通过dfs即可从下往上构建dp
{'id': '剑指 Offer 26', 'name': '树的子结构'} 原思路：暴力针对每个节点进行比对 解法：其实差不多，先动手写一下吧。。。 TODO done
{'id': '236', 'name': '二叉树的最近公共祖先'} 原思路：无 解法：从底向上寻找公共节点进行返回即可，后序遍历（注意把问题情况理清楚，1：在节点两侧；2：p为节点且q在子节点中；3：q为节点且p在子节点中） TODO done
{'id': '124', 'name': '二叉树中的最大路径和'} 原思路：递归即可 解法：确实递归就行 TODO done

{'id': '301', 'name': '删除无效的括号'} 解法：回溯 + 剪枝 为啥跟dfs和bfs有关？不懂 TODO done （不要想着remove，直接用逐个add的方法，以及利用左右括号的分数，回溯过程中让得分有效即可）
 回溯算法相关：

什么括号啊，运算啊，统统都有着先进后出的特性，可以通过栈进行运算
{'id': '162', 'name': '寻找峰值'} TODO (二分的条件以及终止边界条件需要注意)
{'id': '268', 'name': '丢失的数字'} done
{'id': '48', 'name': '旋转图像'} done (注意通过标记防止重复旋转)
{'id': '315', 'name': '计算右侧小于当前元素的个数'} 归并排序+索引数组 TODO
{'id': '29', 'name': '两数相除'} 原思路：1+2+4+8 解法：直接1->2->4->8就能确定，没必要复杂化
除法、n次方、平方根之类的求值都可以先用变步长确定范围（1->2->4->8)然后再用二分法求精确值 done but TODO (注意边界移除问题，以及二分的方法)
{'id': '338', 'name': '比特位计数'} 原思路：遍历所有数字，对每个数字进行二进制转换，判断其中位数为1的数量 解法：奇偶位判断，伪动态规划 f(n) = f(n - 1) + 1 && f(n) = f(n / 2) done
{'id': '371', 'name': '两整数之和'} 原思路：无 解法：主要是两个数同一位为1的情况需要进位，这种进位的情况需要不断循环相加处理，直到没有需要进位为止 TODO （补码的位运算，分为进位和无进位加法）
{'id': '190', 'name': '颠倒二进制位'} 原思路：无 解法：将原数字不断左移，取最左边的数字作为结果，不断右移并和被移出的数字取与 TODO （翻转也可以用二进制的位下标，因为位数为固定32位）
{'id': '8', 'name': '字符串转换整数 (atoi)'} 原思路：遍历字符，获取有效字符串后转化为数字 解法：自动机，根据状态转移map来进行识别并进行计算（这属于一边识别一边计算） TODO done (不用自动机，在循环中做状态转换即可)
{'id': '127', 'name': '单词接龙'} done (单词领接表字典 + bfs简简单单)
{'id': '剑指 Offer 49', 'name': '丑数'} 3指针，好好琢磨即可 done but TODO
{'id': '149', 'name': '直线上最多的点数'} 暴力即可 done but TODO
{'id': '13', 'name': '罗马数字转整数'} done
{'id': '347', 'name': '前 K 个高频元素'} 原思路：记录次数后排序 解法：记录次数后快排切分 done


daily leetcode
2023年10月7日：
	88. 合并两个有序数组 逆向双指针
    80. 删除有序数组中的重复项 II 快慢指针+计数器 TODO
    189. 轮转数组 翻转数组 TODO
	380. O(1) 时间插入、删除和获取随机元素 哈希表+数组末尾删除交换 TODO
    134. 加油站 TODO 贪心+过往路径开始的任一起点都是无效起点
    12. 整数转罗马数字 TODO 贪心hash表
    14. 最长公共前缀 TODO 链表找前缀