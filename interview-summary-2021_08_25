java为啥不怎么用多进程
单核多核cpu在多线程和多进程之间的区别
弱引用虚引用是干啥用的
jvm内存和直接内存有啥区别，效率是否相同
CAS是啥
常量池里放的什么
TLAB是啥
类加载机制
为什么数组没有直接进入老年代
reference和softreference区别
如何观察到GC详细参数
现在项目是采用什么服务器，为什么

java
	java编译过程 javac编译成字节码 JVM解释器 JIT编译器
	jvm内存结构 线程内部 虚拟机栈（局部变量表） 本地方法栈 程序计数器 线程共享 方法区元/空间 堆
	string存在哪 方法区字符串常量池 new "" + 
	类加载机制 加载 class放入方法区 堆中生产class对象 链接 代码规范性检查 准备int=0 解析 初始化 int=9
	对象加载流程
	类加载器分类 bootstrap extension application userdefine
	双亲委派机制 向上递归找类加载器，优先让父级加载器进行类加载
	反射 解释型语言能够动态获取类属性并且进行修改的过程
	java序列化 对象持久化或在网络中传输
	java异常 throwable error exception runtimeexception ioexception
	xio 
	arraylist扩容 len + len >> 1 1.5倍 modCount乐观并发控制 静态变量减少初始化成本 ensureCapacity减少扩容成本
	hashmap不同java版本的区别 1.7 头插 扩容再插 链表+数组 1.8 尾插 链表+数组、红黑树 插了再扩容
	concrruentHashMap 1.7 总计16个segment上加锁 1.8 entry加锁，并发量提升
	死锁代码 线程1资源2 -> 资源1 线程2资源1 -> 资源2
	sleep()和wait() 后者放弃cpu进入等待状态，notify后被唤醒
	synchronized原理优化 偏向锁（不释放锁） 轻量级锁（CAS+自旋10次） 重量级锁（内核态用户态切换 中断） 锁消除（不予锁定）
	CAS compare and swap 比较内存中的值和线程预期的原始值是否相同
	volatile 禁止指令重排 保持内存可见性
	内存屏障 invalid buffer queue 
	CPU工作流程 外存 -> 内存 -> 控制器执行指令 -> 读入寄存器 -> 计算 -> 结果放入内存/外存
	JMM 线程独占内存 共享内存
	ThreadLocal原理 每个thread内部有一个map，key为threadlocal引用 value为值，保证线程资源的独占性
	ThreadLocal问题 threadlocalmap线性探测法，为了节省空间，key为弱引用，便于回收，key变null，value还在，thread -> map -> entry -> value强引用链一直存在，需要手动remove
	线程池参数 核心线程数 最大线程数 队列 饱和策略 
	线程池类型 fixed：核心线程数=最大线程数 single：核心线程数=1 cache： 
	线程池流程 核心线程->队列->最大线程
	线程池问题 任务过多导致OOM
	Runnable Callable区别 后者有返回结果
	submit excute 后者能够通过callable接口的get方法获取返回结果
	JUC java并发包 重点：atomicxxx cas + volatile  semaphore xxx aqs
	AQS clh抽象队列 双向链表
	弱引用 发现就回收，跟强引用比就是少个GC判断对象是否存活的过程，比如threadlocal就用了
	jvm命令 jps jstat -gc jmap jstack
	常量池位置 1.7 方法区 1.8 元空间
	对象创建过程 类加载 -> 分配空间 -> 准备 -> 对象头填充（8字节的倍数，锁状态标识） -> init
	TLAB thread local alloction buffer 线程本地分配内存，用于保证对象内存分配时的线程安全性
	查看堆分代信息 jstat -gc
	分担担保机制 minor GC时判断老年代的可用空间是否大于新生代
	哪些大对象进老年代 byte数组 长字符串
	垃圾清除算法 标记清除 标记整理 （适用于对象存活较多的场景，年老代） 复制（适用于对象清除较多的场景，年轻代） 分代
	垃圾回收器 serial 串行 parNew 多线程串行 parallel 并行 CMS 并发 标记清除法（gc线程和用户线程同时运行）初始标记 并发标记 最终标记 清除 碎片多 CPU敏感 无法处理浮动垃圾 G1 地址不连续 标记整理 + 复制 主要瓶颈为转移空间 zgc 读屏障+着色指针 减少了转移的耗时
	生产环境jvm参数设置 垃圾回收器 G1 年轻代 3g 堆 8g





计算机网络
	tcp/ip五层协议中分别有什么常用协议 ftp telnet ssl tls icmp  
	tcp/ip五层协议中分别在传输过程中起了什么作用，每一层是干什么的，比如传输层是负责将数据传输到另一台机器
	握手挥手过程以及其中的状态 syn ack/syn ack fin -> fin_wait ack -> close_wait fin -> closed ack -> time_wait
	time_wait过多是什么原因导致的如何定位 高并发短连接，netstat
	linux查看网络的命令 netstat -apn | grep portno ps -aux | grep pid/portno
	tcp和udp的区别 可靠传输 拥塞控制 超时重传 流量控制 不可靠传输 尽最大努力交付
	arq是啥 自动重传协议 连续arq协议：维护了一个窗口，一坨一坨传 停等arq协议
	拥塞窗口是如何运作的 慢开始 拥塞避免 快恢复 快重传
	url地址输入的过程 DNS解析 TCP建立连接 IP寻址 ARP解析 MAC映射 
	状态码分类 200 201 301 302 400 401 402 403 404 405 409 500 502 503
	cookie和session是配套使用的吗 是
	uri和url实际举例区别 身份证 网址
	http不同版本的区别 1.1：409，缓存，长链接 2.0：header缩小，多路请求复用 3.0：udp quic
	https的加密过程 对称加密 -> 非对称加密 加密 对称加密的秘钥 证书里是私钥加密之后的公钥，浏览器自带的公钥可以解密出来，解密之后需要验签和验证域名，然后再对称加密
	rpc是啥协议
	跨域问题
	正向代理 反向代理


操作系统
	进程线程协程的区别 知乎 进程线程都是CPU运行的一段时间，只是线程是进程的细粒度划分而已，好比cpu执行10s，其中前5s是线程a，后5s是线程b，线程之间的内存和代码段是共享进程的，但是线程有各自的寄存器数据（大概），携程其实就是单个用户态的线程，颗粒度更小而已
	进程和线程的状态有啥区别 差不多
	进程间通信方式面试题 管道 亲缘进程 半双工 效率低 命名管道 不限制 效率低 消息队列 队列消息滞留 socket 共享内存 最快 共同物理内存 不同逻辑地址
	进程调度算法 先到先服务 短作业优先 时间片 优先级
	指令执行的流程 代码数据从外存读到内存，控制器获取指令解码，需要的数据放到寄存器中，执行指令，结果返回到寄存器中
	内存管理段页式巴拉巴拉 逻辑代码段 大块等分页面 先分代码段再分页面
	虚拟内存、缺页中断 每个进程分配逻辑地址空间 页面不存在主存中需要从外存调入


mysql
	innodb和myisam的区别 事务 行锁 外键 聚簇索引 
	不同字符集之间有什么区别
	并发问题 脏读 不可重复读 幻读
	隔离级别 未提交读->脏读 提交读->不可重复读 可重复读->幻读 innodb MVVC next-key lock gap lock + record lock 序列化 读时共享锁 写时排他锁 ->nothing
	MVCC是啥 undo log readview 版本链 事务可见性 select是否产生新的readview
	大表优化 分库 分表 纵向拆分 横向拆分 
	sql语句执行过程 连接器 分析器 优化器 执行器 写redo log prepare 写bin log commit
	问题排查 no cache看是否慢 where找到最少那一列 explain 查看索引情况，看是否用到索引 开启慢查询日志 show processlist查看线程
	设计原则 负向优化 节约字段 组合索引 最左匹配 过早优化 建索引原则：非频繁更新，需要排序，区分度高，数据稀疏
 


redis
	为啥要用 数据类型丰富5种 性能高 原生支持分布式 可持久化
	数据类型 string（字符数组） hash（只支持简单map 数组+链表 双字典 渐进式rehash） list（链表） set zset（跳表 不用b树）
	持久化机制 rdb 快照 子进程 共享内存 aof 持久化 aof重写
	io模型 单线程模型 io多路复用 事件注册回调机制 一个线程可以监听多个socket通信 非阻塞
	淘汰策略 惰性删除 定时删除 -> all keys volatile LRU LFU TTL random 过期字典
	缓存问题 缓存穿透 缓存无效key 布隆过滤器 缓存雪崩 前：redis高可用集群 随机设置过期时间 热点数据禁止过期 中：限流 降级 后：恢复
	数据一致性 cache aside 删缓存 更新数据库
	分布式解决方案 集群 cluster 分片  主从 读写分离 全量同步rdb 增量同步 偏移量 写瓶颈 哨兵 高可用 故障转移 消息中心 集群监控
	分布式锁 set if not exist 
	epoll
	生产环境是怎么样的


订单系统
	订单流程 下单：不同入口（h5，公众号，app，小程序）->创建订单->支付：不同渠道（支付宝、微信、苹果）->支付回调->履约（开课、发短信、发消息、优惠劵、物流）
	订单信息 商品信息 + 用户信息 + 支付信息 + 履约信息 + 物流信息
	订单状态 初始状态->支付->（支付成功、失败、超时）->（开课中、成功、失败）->（退款中、成功、失败）
	订单实际方案 基于base法则 尽量确保最终一致性 线程池+定时任务xxljob
	订单存在问题 线程池问题：订单量激增导致线程池拒绝、业务没有隔离开、大量线程池容易导致fullgc、没有补偿机制和监控 定时任务问题：@schedule单线程导致任务饿死、任务没有设置优先级、没有监控和报警机制 其他问题：统计类需求和用户 
	重构方案 线程池->kafka消息队列 重试补偿机制 定时任务->xxljob 任务增加逆向操作流程
	遇到问题
	分布式解决方案
	canal
	kafka
	订单数据怎么过滤的？kafka的生产者从哪来？ canal server配置来的
	实际kafka的配置？
	canal的角色 监听的是库还是表 mysql的整个bin log 但是可以过滤筛选 发出的消息如何保证有序 消息格式是怎样的 一条消息多大
	kafka 配置如何 多少个topic 多少个partition 如何保证接受的消息有序 
	订单系统如何设计
	数量大了怎么办
	


kafka

mongo
	效率对比 不带id>带id mongo > mysql
	mmap 减少了用户进程缓存到kernel缓存再到磁盘的过程，直接将磁盘空间映射到用户地址空间
	预分配 容易让数据变得集中，地址变得连续
	写操作流程 写内存直接返回
	事务
	索引 B+树 非聚簇索引 recordId 部分索引

ES
	term dictionary prefix tree position list roaring bit map 跳表
	写入流程 内存 translog 磁盘
	深度分页 scroll search_after 相同时间戳
	删除 标识 合并segment
	写入 内存 segment可见
	






linux

设计模式


项目介绍

这个订单异步化改造主要是对我们订单原有基于线程池的方案就行了一些优化，因为之前我们订单下单后的一些逻辑，包括开课、短信、活动、物流等，都是在用户支付完成后，在线程池中进行的。

这样就可能会导致一些问题：

首先是当订单量如果突增的话，大量订单会导致线程池拒绝的风险，
二是之前的过程中，对于业务执行失败的订单，缺少了异常记录的操作，
三是所有不同类型的业务耦合性太强，希望去对他进行一个拆分，比如说一笔订单支付成功后，活动的执行失败不应该影响后续开课的业务执行。

因此对他进行了优化，当时采用了canal+kafka的方式，我们这边订单支付后的回调接口，是将订单状态由0改为1，所以canal只需要监听订单表的变化订单；发送到kafka中，对于这个topic我创建了一个负责清洗的消费者，会解析canal发送的消息，只过滤状态值从0变为1的订单数据；

之后将订单id再次进行转发；

另外我是将订单后置的履约业务拆分为独立的互不影响的几个子业务，将一些共有的方法抽象为一个抽象类，其中提供了模板方法，每个子业务只需要继承这个抽象类，在其中定义自己的业务码，编写各自的业务逻辑就可以很好的扩展，也方便了以后其他同事的开发。

每个子业务都作为一个消费者组来对支付成功的订单topic进行监听，接受到以后通过orderId就可以还原订单、商品、用户的一些数据信息，通过在redis分布式锁+mongo中记录执行结果，来确保原子性避免重复消费（因为对每个子业务定义了业务码，可以区分）。其次对于执行异常的订单，会根据订单id、业务码记录下来，通过定时任务补偿的方式确保最终一致性。


可能后续会问道或者可以在介绍中补充的问题：

线程池相关，各个参数和提交流程
canal的机制，mysql数据同步
一致性方案
分布式锁
订单量特别大怎么办：读写分离、缓存、分库分表（https://blog.csdn.net/weixin_48182198/article/details/108475822、）
遇到的问题：


自我介绍：
	面试官你好，我叫吕超毅，17年毕业于华中科技大学软件工程学院，现在在网易有道从事服务端的Java开发
	之前主要参与过的项目有：有道云课系统（负责整个系统的框架技术选型以及日常迭代）、有道少儿英语的订单系统（主要负责订单系统的重构和优化）、爬虫数据监控系统（负责爬虫脚本开发以及数据清洗统计）
	主要的技术栈有：Java全家桶（包括Spring、SpringBoot之类的），数据库包括：MySQL、Redis、MongoDB等，其他中间件的话：kafka、ElasticSearch用过一些