java为啥不怎么用多进程
单核多核cpu在多线程和多进程之间的区别
弱引用虚引用是干啥用的
jvm内存和直接内存有啥区别，效率是否相同
CAS是啥
常量池里放的什么
TLAB是啥
类加载机制
为什么数组没有直接进入老年代
reference和softreference区别
如何观察到GC详细参数
现在项目是采用什么服务器，为什么

java
	java编译过程 javac编译成字节码 JVM解释器 JIT编译器
	jvm内存结构 线程内部 虚拟机栈（局部变量表） 本地方法栈 程序计数器 线程共享 方法区元/空间 堆
	string存在哪 方法区字符串常量池 new "" + 
	类加载机制 加载 class放入方法区 堆中生产class对象 链接 代码规范性检查 准备int=0 解析 初始化 int=9
	类加载器分类 bootstrap extension application userdefine
	双亲委派机制 向上递归找类加载器，优先让父级加载器进行类加载
	反射 解释型语言能够动态获取类属性并且进行修改的过程
	java序列化 对象持久化或在网络中传输
	java异常 throwable error exception runtimeexception ioexception
	xio 
	arraylist扩容 len + len >> 1 1.5倍 modCount乐观并发控制 静态变量减少初始化成本 ensureCapacity减少扩容成本
	hashmap不同java版本的区别 1.7 头插 扩容再插 链表+数组 1.8 尾插 链表+数组、红黑树 插了再扩容
	concrruentHashMap 1.7 总计16个segment上加锁 1.8 entry加锁，并发量提升
	死锁代码 线程1资源2 -> 资源1 线程2资源1 -> 资源2
	sleep()和wait() 后者放弃cpu进入等待状态，notify后被唤醒
	synchronized原理优化 偏向锁（不释放锁） 轻量级锁（CAS+自旋10次） 重量级锁（内核态用户态切换 中断） 锁消除（不予锁定）
	CAS compare and swap 比较内存中的值和线程预期的原始值是否相同
	volatile 禁止指令重排 保持内存可见性
	内存屏障 invalid buffer queue 
	CPU工作流程 外存 -> 内存 -> 控制器执行指令 -> 读入寄存器 -> 计算 -> 结果放入内存/外存
	JMM 线程独占内存 共享内存
	ThreadLocal原理 每个thread内部有一个map，key为threadlocal引用 value为值，保证线程资源的独占性
	ThreadLocal问题 threadlocalmap线性探测法，为了节省空间，key为弱引用，便于回收，key变null，value还在，thread -> map -> entry -> value强引用链一直存在，需要手动remove
	线程池参数 核心线程数 最大线程数 队列 饱和策略 
	线程池类型 fixed：核心线程数=最大线程数 single：核心线程数=1 cache： 
	线程池流程 核心线程->队列->最大线程
	线程池问题 任务过多导致OOM
	Runnable Callable区别 后者有返回结果
	submit excute 后者能够通过callable接口的get方法获取返回结果
	JUC
	AQS
	弱引用 发现就回收，跟强引用比就是少个GC判断对象是否存活的过程，比如threadlocal就用了
	jvm命令 jps jstat -gc jmap jstack
	常量池位置 1.7 方法区 1.8 元空间
	对象创建过程 类加载 -> 分配空间 -> 准备 -> 对象头填充（8字节的倍数，锁状态标识） -> init
	TLAB thread local alloction buffer 线程本地分配内存，用于保证对象内存分配时的线程安全性
	查看堆分代信息 jstat -gc
	分担担保机制 minor GC时判断老年代的可用空间是否大于新生代
	哪些大对象进老年代 byte数组 长字符串
	垃圾清除算法 标记清除 标记整理 （适用于对象存活较多的场景，年老代） 复制（适用于对象清除较多的场景，年轻代） 分代
	垃圾回收器 serial 串行 parNew 多线程串行 parallel 并行 CMS 并发 标记清除法（gc线程和用户线程同时运行）初始标记 并发标记 最终标记 清除 碎片多 CPU敏感 无法处理浮动垃圾 G1 地址不连续 标记整理 + 复制 主要瓶颈为转移空间 zgc 读屏障+着色指针 减少了转移的耗时
	生产环境jvm参数设置 垃圾回收器 G1 年轻代 3g 堆 8g





计算机网络
	tcp/ip五层协议中分别有什么常用协议 ftp telnet ssl tls icmp  
	tcp/ip五层协议中分别在传输过程中起了什么作用，每一层是干什么的，比如传输层是负责将数据传输到另一台机器
	握手挥手过程以及其中的状态 syn ack/syn ack fin -> fin_wait ack -> close_wait fin -> closed ack -> time_wait
	time_wait过多是什么原因导致的如何定位 高并发短连接，netstat
	linux查看网络的命令 netstat -apn | grep portno ps -aux | grep pid/portno
	tcp和udp的区别 可靠传输 拥塞控制 超时重传 流量控制 不可靠传输 尽最大努力交付
	arq是啥 自动重传协议 连续arq协议：维护了一个窗口，一坨一坨传 停等arq协议
	拥塞窗口是如何运作的 慢开始 拥塞避免 快恢复 快重传
	url地址输入的过程 DNS解析 TCP建立连接 IP寻址 ARP解析 MAC映射 
	状态码分类 200 201 301 302 400 401 402 403 404 405 409 500 502 503
	cookie和session是配套使用的吗 是
	uri和url实际举例区别 身份证 网址
	http不同版本的区别 1.1：409，缓存，长链接 2.0：header缩小，多路请求复用 3.0：udp quic
	https的加密过程 对称加密 -> 非对称加密 加密 对称加密的秘钥 证书里是私钥加密之后的公钥，浏览器自带的公钥可以解密出来，解密之后需要验签和验证域名，然后再对称加密
	rpc是啥协议


操作系统
	进程线程协程的区别 知乎 进程线程都是CPU运行的一段时间，只是线程是进程的细粒度划分而已，好比cpu执行10s，其中前5s是线程a，后5s是线程b，线程之间的内存和代码段是共享进程的，但是线程有各自的寄存器数据（大概），携程其实就是单个用户态的线程，颗粒度更小而已
	进程和线程的状态有啥区别 差不多
	进程间通信方式面试题 管道 亲缘进程 半双工 效率低 命名管道 不限制 效率低 消息队列 队列消息滞留 socket 共享内存 最快 共同物理内存 不同逻辑地址
	进程调度算法 先到先服务 短作业优先 时间片 优先级
	指令执行的流程 代码数据从外存读到内存，控制器获取指令解码，需要的数据放到寄存器中，执行指令，结果返回到寄存器中
	内存管理段页式巴拉巴拉 逻辑代码段 大块等分页面 先分代码段再分页面
	虚拟内存、缺页中断 每个进程分配逻辑地址空间 页面不存在主存中需要从外存调入


mysql
	innodb和myisam的区别 事务 行锁 外键 聚簇索引 
	不同字符集之间有什么区别
	并发问题 脏读 不可重复读 幻读
	隔离级别 未提交读->脏读 提交读->不可重复读 可重复读->幻读 innodb MVVC next-key lock gap lock + record lock 序列化 读时共享锁 写时排他锁 ->nothing
	MVCC是啥 undo log readview 版本链 事务可见性 select是否产生新的readview
	大表优化 分库 分表 纵向拆分 横向拆分 
	sql语句执行过程 连接器 分析器 优化器 执行器 写redo log prepare 写bin log commit
	问题排查 no cache看是否慢 where找到最少那一列 explain 查看索引情况，看是否用到索引 开启慢查询日志 show processlist查看线程
	设计原则 负向优化 节约字段 组合索引 最左匹配 过早优化 建索引原则：非频繁更新，需要排序，区分度高，数据稀疏
 


redis
	为啥要用 数据类型丰富5种 性能高 原生支持分布式 可持久化
	数据类型 string（字符数组） hash（只支持简单map 数组+链表 双字典 渐进式rehash） list（链表） set zset（跳表 不用b树）
	持久化机制 rdb 快照 子进程 共享内存 aof 持久化 aof重写
	io模型 单线程模型 io多路复用 事件注册回调机制 一个线程可以监听多个socket通信 非阻塞
	淘汰策略 惰性删除 定时删除 -> all keys volatile LRU LFU TTL random 过期字典
	缓存问题 缓存穿透 缓存无效key 布隆过滤器 缓存雪崩 前：redis高可用集群 随机设置过期时间 热点数据禁止过期 中：限流 降级 后：恢复
	数据一致性 cache aside 删缓存 更新数据库
	分布式解决方案 集群 cluster 分片  主从 读写分离 全量同步rdb 增量同步 偏移量 写瓶颈 哨兵 高可用 故障转移 消息中心 集群监控
	分布式锁 set if not exist 
	epoll
	生产环境是怎么样的


订单系统
	订单流程 下单：不同入口（h5，公众号，app，小程序）->创建订单->支付：不同渠道（支付宝、微信、苹果）->支付回调->履约（开课、发短信、发消息、优惠劵、物流）
	订单信息 商品信息 + 用户信息 + 支付信息 + 履约信息 + 物流信息
	订单状态 初始状态->支付->（支付成功、失败、超时）->（开课中、成功、失败）->（退款中、成功、失败）
	订单实际方案 基于base法则 尽量确保最终一致性 线程池+定时任务xxljob
	订单存在问题 线程池问题：订单量激增导致线程池拒绝、业务没有隔离开、大量线程池容易导致fullgc、没有补偿机制和监控 定时任务问题：@schedule单线程导致任务饿死、任务没有设置优先级、没有监控和报警机制 其他问题：统计类需求和用户 
	重构方案 线程池->kafka消息队列 重试补偿机制 定时任务->xxljob 任务增加逆向操作流程
	遇到问题
	分布式解决方案
	canal
	kafka


kafka

mongo

linux

设计模式



